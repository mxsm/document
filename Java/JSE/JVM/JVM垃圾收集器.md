### 1 垃圾收集算法

#### 1.1 标记 --- 清除

**标记清除算法分为两步**：

1.  **标记需要回收的对象  -- 标记**
2. **标记完成后统一回收被标记需要回收的对象。 -- 清除**

**优点：**

- 解决循环引用问题
- 必要时才回收(当内存不足的情况)

**缺点：**

- 标记和清除两个过程效率都不高
- 会产生大量的不连续的内存碎片，空间碎片太多会导致以后程序中需要分配比较大的对象的时候，无法找到足够的连续的内存而不得不提前出发一次垃圾收集的动作。
- 回收的时候会触发 **`stop the world`**

#### 1.2 标记 --- 整理

和标记清除算法一样 标记整理也分为两步且第一步是相同的：

1. **将存活的对象标记--标记**
2. **移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收---整理阶段**

**优点：**

- 不会产生内存碎片

**缺点：**

- 整理的效率不高

#### 1.3 复制算法

**复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的**。 当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。**接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址**。

​         此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。

### 2. 相关概念说明

- **并行（Parallel）**：指多条 **`垃圾收集线程并行`** 工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
- **Minor GC 和 Major GC (Full GC)**
  - **新生代GC（Minor GC）**：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
  - **老年代GC（Major GC / Full GC）**：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。
- **吞吐量：** 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。
  虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

### 3. 垃圾收集器

下面看一下垃圾收集器的相关图([来源Oracle官网博客已放入我的github文档目录](https://blogs.oracle.com/jonthecollector/our-collectors))：

![图片](https://github.com/mxsm/document/blob/master/image/JSE/collectors.jpg?raw=true)

注：图中的 **`？`** 表示什么呢，以后的GC收集器的另一外的实现。比如 **`JDK11`** **`G1`** 垃圾收集器。

上图展示了六种(或者说7种 包括G1)不同的收集器在新生代和老年代的垃圾收集。如果两个收集器之间有连线说明说明可以搭配使用 。·	

### 4. Serial收集器

- **特性：** 这个收集器是一个`单线程`的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。停止其他的线程工作就是我们常说的 **`Stop the world`**

- **应用场景：**

  **`Serial`** 收集器是虚拟机运行在 **`Client`** 模式下的默认新生代收集器。

  可以用命令

  ```
  java -version 查看
  ```

  一般情况下都是Server模式(Windows 平台可以搜一下jvm.cfg文件)

- **优点：**

  简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。对于自由一个CPU来说，由于现在的电脑大多数都是多核心CPU所以这个收集器就很少用

- **原理图解：**

  ![图解](https://github.com/mxsm/document/blob/master/image/JSE/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png?raw=true)

- **适用范围：**

  - **新生代--Serial**
  - **老年代--Serial Old**

  所以这个收集器包含了处理新生代的 **`Serial(复制算法)`** 收集器和处理老年代的 **`Serial Old(标记整理算法)`**  收集器

### 5. ParNew收集器

- **特性：**

  **`ParNew`**  收集器其实就是 **`Serial(新生代)`** 收集器的多线程版本，除了使用了多线程以外其他的基本上都和 **`Serial(新生代)`** 收集器差不多。

- **应用场景：**

  ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。

  很重要的原因是：除了 **`Serial`** 收集器外，目前只有它能与 **`CMS`** 收集器配合工作。
   在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器—— **`CMS`** 收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器 **`Parallel Scavenge`** 配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择 **`ParNew`**或者 **`Serial`** 收集器中的一个。

- **优点：**

  多线程收集器

- **原理图解：**

  ![图解](https://github.com/mxsm/document/blob/master/image/JSE/ParNew.png?raw=true)









参考文档：

https://www.jianshu.com/p/50d5c88b272d

https://crowhawk.github.io/2017/08/15/jvm_3/

https://tech.meituan.com/2017/12/29/jvm-optimize.html

https://blogs.oracle.com/jonthecollector/our-collectors

http://ifeve.com/useful-jvm-flags-part-7-cms-collector/