### 1. 选择优化的数据类型

数据类型优化的原则：

- **更小的通常更好**

  尽量的使用可以正确存储数据的最小数据类型（**例如存0-200,tinyint**）。更小的数据类型通常更快 --- **占用更少的磁盘，内存，CPU缓存，并且处理时需要的CPU周期更少。**

- **简单就好**

  简单的数据类型的操作通常需要更少的CPU周期。整形比字符串操作代价更加低。因为字符集的排序规则比整型更加复杂。下面有两个例子：

  - 储存日期和时间应该使用MySQL內建的类型如：**`data time datatime`** 而不是用字符串来存储。

  - 用整数来存储IP地址

    ```mysql
    mysql> select inet_aton('192.168.0.1');
    +--------------------------+
    | inet_aton('192.168.0.1') |
    +--------------------------+
    |               3232235521 |
    +--------------------------+
    ```

    ```mysql
    mysql> select inet_ntoa(3232235521);
    +-----------------------+
    | inet_ntoa(3232235521) |
    +-----------------------+
    | 192.168.0.1           |
    +-----------------------+
    ```

    通过函数来转换存储。

- **尽量避免NULL**

  通常情况下NULL是列的默认属性，但是通常情况下最好指定为**Not NULL**。除非真的需要存储**NULL**值。----对于包含NULL的列，使得索引、索引统计、和值比较都更加复杂。可为NULL的列会使用更多的存储空间，MySQL中也需要特殊处理。当可为NULL的列被索引时，每个索引纪录需要一个额外的字节。

  所以在要建立索引的字段上尽量避免设计成为NULL的列。

### 2. 整数类型

- **整数**

  - **TINYINT**

    存储空间位数：8

  - **SMALLINT**

    存储空间位数：16

  - **MEDIUMINT**

    存储空间位数：24

  - **INT**

    存储空间位数：32

  - **BIGINT**

    存储空间位数：64

  整数类型可以选择UNSIGNED属性，表示不允许负数。无符号和有符号的存储空间一样，具有相同的性能。

  **整数类型指定宽度例如INT(11)，对于大多数引用来说没有意义。不会限制合法值的范围。对于储存和计算来说INT(1)和INT(11)都是一样的**

- **实数**

  实数是带有小数部分的数字。然而不只是为了存储小数部分；也可以使用DECIMAL存储比BIGINT还大的整数。float比DECIMAL更加快。原因是CPU支持浮点数运算而不支持DECIMAL运算。

### 3. 字符串类型

- **可变长度 `varchar`**

  比定长更加节省空间，因为他是按需分配。例外情况---Mysql表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储。

  **`varchar`** 会使用1或2个额外的字节来纪录字符串的长度：长度小于等于255字节，则使用一个字节，如果大于255小于等于65535 则使用两个字节(PS：这里可以看出来varchar的最大值65535，因为至多只有两个字段来纪录大小)。

    **`varchar`** 的好处就是节省空间。能够提高性能，但是同样的由于是变长在更新(**UPDATE**)时候可能使行变得更加长。如果一个行占用的空间增长，并且页内没有更多的空间可以存储，在这种情况下不同的引擎处理的方式不一样，InnoDB需要分裂页来使得行可以放到页内。

- **固定长度 `char`**

  char是固定长度，根据定义的长度分配足够的空间。当存储char值时MySQL会去除掉后面的空字符串。

  ```sql
  INSERT INTO chartest VALUES (2,' char1 ');
  SELECT CONCAT("'",char_col,"'") FROM chartest WHERE char_col = ' char1 ';
  ```

  如上两条语句查询出来的数据是去除了char1后面的空字符。查询的时候也可以去除后面空字符也能查询出来。

  char比较适合存储一些比**较短或者定长**的字符串。比如MD5。对于经常变更的数据，char也比varchar好。定长的char不容易产生碎片。 对于非常短的列，char比varchar在存储空间上也更有效率。

  > 使用VARCHAR(5)和VARCHAR(200)存储 hello 的空间开销是一样的。那么使用更短的列有什么优势？
  >
  > 更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部的值。尤其是使用内存临时表时表进行排序或者操作时会特别糟糕。在利用磁盘临时表进行排序时也同样的糟糕。
  > 所以最好的策略就是只分配正则需要的空间，用多少分配多少，估算当前列的最大值。

  