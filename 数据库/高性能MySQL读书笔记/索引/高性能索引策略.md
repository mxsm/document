### 1. 独立的列

如果查询过程中不是独立的列，则Mysql就不能使用索引。**独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。** 始终将索引列单独放在比较符的一侧。

```sql
select actor_id from actor where actor_id+1 = 5
```

上面的SQL就不能使用到索引。这种情况应该避免！

### 2. 前缀索引和索引的选择

有时候需要索引很长的字符列，这会让索引变得大而且慢！**通过Hash索引可以解决这个问题**，但是有时候这样做还不够。可以从以下方面来着手：

- **索引开始的部分字符串**

  **优点：大大的节约索引的空间，提高索引的效率。但这样也会降低索引的选择性。**

  >**什么是索引的选择性？**
  >
  >不重复的索引值（也叫做基数）和表中纪录总数(#T)的比值，范围从1/#T ~ 1 之间。
  >
  >索引的选择性越高则查询效率越高，因为选择性高的索引能够过滤掉更多的行。唯一索引的选择性为1，这是最好的索引选择性，性能也最好。

  一般情况下某个列前缀的选择性也是足够高的，**足够满足性能查询。对于BLOB、和TEXT或者很长的varchar。必须使用前缀索引。** 因为MySQL不允许索引这些列的完整长度。

  > **使用诀窍：**
  >
  > 选择足够长的前缀以保证较高的选择性，同时又不能太长(节约空间)。前缀足够长，以使得前缀索引的选择性接近于索引整个列。（索引前缀的基数接近于完整列的基数）

  如何选择合适的长度演示：

  比如我要查询city使用前缀值为多少比较合适？

  ```sql
  --获取city的选择性
  SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo 
  --获取不同前缀的选择性
  SELECT 
  COUNT(DISTINCT LEFT(city,3))/COUNT(*) as a1,
  COUNT(DISTINCT LEFT(city,4))/COUNT(*) as a2,
  COUNT(DISTINCT LEFT(city,5))/COUNT(*) as a3,
  COUNT(DISTINCT LEFT(city,6))/COUNT(*) as a4
  FROM city_demo 
  
  ```

  通过对比找出和第一个sql语句最接近的数值(当然可能长度还更长)。假如是LEFT(city，5)这个就已经已经接近了。那么创建前缀索引：

  ```sql
  mysql>ALTER TABLE city_demo ADD KEY(ctiy(7));
  ```

  缺点：无法使用前缀索引做Order By和Group By，同样也无法使用前缀索引做覆盖扫描。