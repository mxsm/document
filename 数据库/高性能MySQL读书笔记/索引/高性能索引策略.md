**从索引的角度来提高数据库速度**

### 1. 独立的列

如果查询过程中不是独立的列，则Mysql就不能使用索引。**独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。** 始终将索引列单独放在比较符的一侧。

```sql
select actor_id from actor where actor_id+1 = 5
```

上面的SQL就不能使用到索引。这种情况应该避免！

### 2. 前缀索引和索引的选择

有时候需要索引很长的字符列，这会让索引变得大而且慢！**通过Hash索引可以解决这个问题**，但是有时候这样做还不够。可以从以下方面来着手：

- **索引开始的部分字符串**

  **优点：大大的节约索引的空间，提高索引的效率。但这样也会降低索引的选择性。**

  >**什么是索引的选择性？**
  >
  >不重复的索引值（也叫做基数）和表中纪录总数(#T)的比值，范围从1/#T ~ 1 之间。
  >
  >索引的选择性越高则查询效率越高，因为选择性高的索引能够过滤掉更多的行。唯一索引的选择性为1，这是最好的索引选择性，性能也最好。

  一般情况下某个列前缀的选择性也是足够高的，**足够满足性能查询。对于BLOB、和TEXT或者很长的varchar。必须使用前缀索引。** 因为MySQL不允许索引这些列的完整长度。

  > **使用诀窍：**
  >
  > 选择足够长的前缀以保证较高的选择性，同时又不能太长(节约空间)。前缀足够长，以使得前缀索引的选择性接近于索引整个列。（索引前缀的基数接近于完整列的基数）

  如何选择合适的长度演示：

  比如我要查询city使用前缀值为多少比较合适？

  ```sql
  --获取city的选择性
  SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo 
  --获取不同前缀的选择性
  SELECT 
  COUNT(DISTINCT LEFT(city,3))/COUNT(*) as a1,
  COUNT(DISTINCT LEFT(city,4))/COUNT(*) as a2,
  COUNT(DISTINCT LEFT(city,5))/COUNT(*) as a3,
  COUNT(DISTINCT LEFT(city,6))/COUNT(*) as a4
  FROM city_demo 
  
  ```

  通过对比找出和第一个sql语句最接近的数值(当然可能长度还更长)。假如是LEFT(city，5)这个就已经已经接近了。那么创建前缀索引：

  ```sql
  mysql>ALTER TABLE city_demo ADD KEY(ctiy(7));
  ```

  缺点：无法使用前缀索引做Order By和Group By，同样也无法使用前缀索引做覆盖扫描。

### 3. 多列索引

对于索引来看一下下面的通常的做法：

```sql
CREATE TABLE `vet_friend` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户Id',
  `friend_id` bigint(20) DEFAULT NULL COMMENT '朋友的Id',
  `friend_ship` tinyint(2) DEFAULT '0' COMMENT '状态 0-待同意 1-已同意 2-已拒绝',
  `gmt_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_left_id` (`user_id`),
  KEY `idx_right_id` (`friend_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='好友表';
```

在多个列上面单独建立索引大部分情况并不能提高MySQL的查询效率(通过下面的执行计划)

```sql
EXPLAIN SELECT * FROM vet_activity WHERE gmt_created > date_format('2019-03-25 15:40:07', '%Y%m%d%H%i%s') 

EXPLAIN SELECT * FROM vet_activity WHERE gmt_created = date_format('2019-03-25 15:40:07', '%Y%m%d%H%i%s') AND organization = 'organization'
```

通过查看执行计划：

```
+----+-------------+--------------+------+------------------+------+---------+------+------+-------------+
| id | select_type | table        | type | possible_keys    | key  | key_len | ref  | rows | Extra       |
+----+-------------+--------------+------+------------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | vet_activity | ALL  | gmtCreated_index | NULL | NULL    | NULL |   32 | Using where |
+----+-------------+--------------+------+------------------+------+---------+------+------+-------------+

+----+-------------+--------------+------+-------------------------------------+--------------------+---------+-------+------+------------------------------------+
| id | select_type | table        | type | possible_keys                       | key                | key_len | ref   | rows | Extra                              |
+----+-------------+--------------+------+-------------------------------------+--------------------+---------+-------+------+------------------------------------+
|  1 | SIMPLE      | vet_activity | ref  | gmtCreated_index,organization_index | organization_index | 131     | const |    1 | Using index condition; Using where |
+----+-------------+--------------+------+-------------------------------------+--------------------+---------+-------+------+------------------------------------+
```

在某些情况下没有一个单独索引是非常有效的比如下面的这个SQL语句：

```sql
select film_id, actor_id FROM film_actor where actor_id = 1 or film_id = 1
```

如果在EXPLAIN中看到有索引合并的情况，最好检查一下查询和表结构。

